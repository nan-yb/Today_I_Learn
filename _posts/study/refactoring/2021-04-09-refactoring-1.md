---
title: "리팩토링 1장"
categories:
  - posts
---

1. YAGNI에 이란?

YAGNI(애그니) 란 (“you aren’t going to need it ) 의 줄임말을 뜻하며 풀어 쓰자면 “필요한 작업만 해라"이다.
다른 말로는 간결한 설계 , 점진적 설계 등으로 불린다. YAGNI란 소프트웨어 설계와 아키텍처를 시작단계에서 어느정도 완료해야한다는 기존의 관점에서 , 요구사항 변화에 자연스럽게 대응 할 수 있도록 코드를 작성할 수 있도록 설계하는 방식을 말한다. 프로그램을 작성하다 보면 , 현재는 사용하지 않지만 확장성을 고려해서 미리 작업해 놓은 것들이 있다. 그런 작업들을 하지말라는 원칙을 말한다.

현재는 사용하지 않는 , 미래 어느 시점에 사용될지도 모를 코드를 작성해놓으면 코드가 불필요하게 장황해진다.
게다가 설계나 환경이 변경되었을 때 수정해야하는 코드의 양이 늘어나게 된다. 설계나 환경이 바뀌었는데 이렇게 미리 작업해 놓은 코드를 수정하지 않았다면 나중에 그 코드에서 버그를 발생시킬 확률이 올라간다. 그러니 당장 필요한 작업에 집중하고 쓸데 없는 작업은 하지말라는 것이다.

YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다. 리팩토링으로는 변경하기 어렵기 떄문에 미리 고려해두면 시간이 절약되는 경우도 있다. 하지만 이제 둘 사이의 균형점이 달라졌다. 이러한 경향은 진화형 아키텍쳐 원칙이 발전하는 계기가 됐다. 추가로 진화형 아키텍처는 관련결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다.
YAGNI는 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이며 리팩터링을의 뒷받침이 없다면 효과를 볼 수 없다.

2. 리팩터링을 해야 할 떄가 언제인지 저자의 견해?

   프로그래밍할 때의 리팩터링은 주기적(1시간)으로 한다. 작업 흐름에 리팩터링을 녹이는 방법으로 3의 법칙을 설명 하는데 3의 법칙이란 1. 처음에는 그냥 한다. 2. 비슷한 일을 두 번째로 하게 되면 , 일단 계속 진행한다. 3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다. 라고 설명한다.

[준비를 위한 리팩터링]
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 현재 시점에 코드를 살펴보며 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질만한 부분을 찾는다. 몇가지를 수정한 이후에 중복된 코드가 발생하면 함수 매개변수화 하기를 적용하여 리팩터링을 진행한다.

[이해를 위한 리팩터링]
코드를 수정할때의 리팩터링은 먼저 그 코드가 하는 일을 파악하며 코드를 파악할 때마다 그 코드의 의도가 명확하게 드러나는지 확인하며 , 리팩터링 할 여지가 없는지 찾아본다. 이쯤 되면 코드를 어느정도 이해하는 시점이 오며 이해한 내용을 바탕으로 변수명을 적절한 이름으로 바꾸기도 하며 긴 함수를 잘게 나누기도 한다. 이러한 초기 리팩터링을 창문 닦기로 비교한다.

[쓰레기 줍기 리팩터링]
코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데 없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 이 떄 간단히 수정할 수 있는것은 즉시 고치고 , 시간이 좀 걸리는 일은 메모로 남긴 이후에 중에 처리한다.

[계획된 리팩터링과 수시로 하는 리팩터링]
보기 싫은 코드를 보면 바로 리팩터링 하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
코드를 작성할 때마다 적절히 타협한다. 매개변수화 하거나 개별함수로 나누는 기준을 정하고 상황이 변해 기준이 변한다 하더라도 이미 코드가 깔끔하다면 리팩터링 하기 쉬운 상태가 된다.

[리팩터링 하지말아야 할 때]
외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 리팩터링 하는 것보다 처음부터 새로 작성하는 게 쉬울때도 리팩터링 하지 않는다.

3. 설계 단계에서 모든 요구사항을 알 기 힘드므로 아키텍쳐의 변경이 필요할 때가 많다. 이를 해결하기 위한 저자의 견해?

코딩 전에 아키텍처를 확정지으려 할 때의 문제는 소프트웨어 요구사항을 사전에 모두 파악해야한다는 점에 있다. 하지만 아무리 꼼꼼히 설계를 한 아키텍처여도 개발 단계 뿐만 아니라 완성 단계에서도 실제로 업무에 미치는 영향을 직접 확인하고 나서야 변경되는 코드가 있을 수 있다. 따라서 언제든지 설계를 바뀔 수 있다라는 인식을 가진채 향후 변경에 유연하게 대처 할 수 있게끔 해야한다.

한 가지 방법은 유연성 메커니즘을 소프트웨어에 심어두는 것이다. 함수를 정의 할 때 예상 시나리오에 대응하기 위한 매개변수들을 추가하는 방식이며, 추가 된 매개변수를 유연성 메커니즘으로 부른다. 하지만 무분별하게 매개변수를 추가하다보면 당장의 쓰임에 비해 함수가 너무 복잡해지며 , 또한 깜빡 잊은 매개변수가 있다면 추가해둔 매개변수에 하나를 더 추가해야하기때문에 새로 추가하기가 어려워지며 매개변수를 잘못 설계하다보면 오히려 변화에 대응하는 능력을 떨어뜨리는 경우도 있다. 요구사항이 당초 예상과 다르게 바뀌기 때문일 때도 있고 , 내가 설계한 메커니즘 자체에 결함이 있어서 일때도 있다. 따라서 현재까지 파악한 요구사항만을 해결하는 소프트웨어만을 구축한다. 단 , 이 요구를 멋지게 해결하도록 설계를 한다. 그리고 개발을 진행하면서 사용자의 요구사항에 따라 아키텍처를 리팩터링 하며 바꾼다. 그 과정에서 소프트웨어의 복잡도에 지장을 주지는 메커니즘은 마음껏 추가하지만 , 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다. 호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지않으며 그러다 매개변수를 추가해야할 시점에 함수 매개변수화하기로 해결한다. 리팩토링을 미루면 훨씬 힘들어진다는 확실이 들 때만 유연성 메커니즘을 추가한다.
