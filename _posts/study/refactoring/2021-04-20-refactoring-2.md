---
title: "리팩토링 2장"
categories:
  - posts
---

## 1. 함수의 이름을 짓는 방법과 관련하여 책에 서술된 조언

[기이한 이름]
코드에 궁금성을 자아내는 코드 방식은 좋지 않다. 세계적인 기인이라는 느낌을 풍기고 싶더라도 꾹 참고 코드는 단순하고 명료하게 표현하는게 중요하다. 코드를 명료하게 표현하는 데 가장 중요한 요소는 바로 ‘이름' 이다. 그래서 함수 , 모듈 , 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경 써야한다. 이름 짓기만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다. 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 생각나지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 따라서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

함수는 프로그램을 작은 부분으로 나누는 주된 수단이다. 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며 , 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다. 연결부를 잘 정의하면 시스템에 새로운 부분을 파악하기 쉬워지며 반면 잘못 정의하면 소프트웨어 동작을 파악하기 어려워지며 요구사항이 바뀔 떄 적적히 수정하기 어렵게 하며 지속적인 방해 요인으로 작용한다. 이러한 연결부에서 가장 중요한 요소는 함수의 이름이다.

## 2. 책에 제시된 악취들 중 YAGNI와 가장 잘 어울리는 항목은 무엇인가?

**[추측성 일반화]**  
추측성 일반화는 우리가 민감하게 반응하는 냄새로 , 브라이언 푸트가 지어준 이름이다. 이 냄새는 ‘나중에 필요할 거야'라는 생각으로 당장은 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 그 결과는 물론 이해하거나 관리하기 어려워진 코드다 , 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만 , 그렇지 않는다면 쓸데 없는 낭비일 뿐이다. 당장 걸리적거리는 코드는 눈앞에서 치워 버리자.

하는일이 거의 없는 추상 클래스는 계층 합치기 로 제거한다. 쓸데없이 위임하는 코드는 함수 인라인하기 나 클래스 인라인 하기로 삭제한다. 본문에서 사용되지 않는 매개변수는 함수 선언 바꾸기로 없앤다. 나중에 다른버전을 만들 떄 필요할 거라는 생각에 추가했지만 한 번도 사용한적 없는 매개변수도 이 기법으로 제거한다.
추측성 일반화는 테스트 코드 말고는 사용하는 곳이없는 함수나 클래스에서 흔히 볼 수 있다. 이런 코드를 발견하면 테스트 케이스에서부터 삭제한 뒤에 죽은 코드 제거하기로 날려버리자

## 3. 주석과 악취의 관계에 대해 서술

**[주석과 악취의 관계]**  
주석을 다는게 안좋은건 아니다. 주석은 악취가 아닌 향기를 입힌다. 하지만 주석을 탈취제처럼 사용하는데 문제가 있다.
주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 자주 있기 때문이다. 주석이 많으면 악취를 풍기는 코드가 나오기 쉽다. 실제로 악취가 심하게 난 주석을 리팩터링 했더니 상당량의 주석이 군더더기 였던 적이 많다. 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 , 함수 추출하기를 적용해본다. 이미 추출되어 있는 함수임에도 여전히 설명히 필요하다면 함수 선언 바꾸기 로 함수 이름을 바꿔본다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 어셔선 추가하기가 대기하고 있다. 주석을 남겨야겠다는 생각이 들면 , 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다. 뭘 할지 모를 때라면 우선 주석을 달아두면 좋다. 현재 진행 상황 뿐만 아니라 확실하지 않은 부분에 주석을 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다.

## 4. OOP 개념을 적극 적용하지 않아 함수와 변수들이 제각각 흩어진 코드가 있다. 이 들을 모아 하나의 클래스로 만들고 싶다. 이에 해당하는 ‘악취’에는 무엇이 있는가, 그 이유를 설명하라

**[데이터 뭉치]**  
클래스 두어 개의 필드에서 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 마련해줘야 마땅하다. 데이터뭉치인지 판별하려면 값 하나를 삭제 해본다. 그랬을 때 나머지 데이터만으로는 의미가 없다면 , 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.
기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면 , 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴본다. 이러한 연계 과정은 상당한 중복을 없애고 , 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어진다. 데이터 뭉치가 생산성에 기여하는 방식이다.

**[산탄총수술]**  
코드를 변경할 때 마다 자잘하게 수정해야 하는 클래스가 많다면 변경할 부분이 코드 전반에 퍼져있다는 뜻이다. 이럴 경우 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다. 이럴때는 함께 변경되는 함수 , 필드 들을 모두 한 모듈안에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기를 적용한다. 어설프게 분리된 로직을 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 방법중 좋은 방법이다. 메서드나 클래스가 비대해지지만 나중에 추출하기 좋은 형태로 분리할 수 있다.

## 5. 책에 제시된 악취들 중 서로 상충되는 두 악취를 한 쌍 고르고, 이 둘 사이에 적당한 지점을 찾는 법

서로 상충되는 두 악취는 [중개자] 와 [메시지 체인]이다. 중개자는 캡슐화 과정에서 자주 이뤄지는 위임을 말하며 위임이 지나치게 과하면 문제가 될 수 있다라고 설명하며 악취가 난다고 말하는 데 이와 상충되게 메시지 체인은 이러한 내용들과는 다르게 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식의 작업을 하지말라고 얘기한다.

제 생각은 체인을 구성하는 객체 중 특정 하나를 계속 사용하는게 반복된다면 해당 객체는 중개자의 기능을 사용하며 반대의 경우에는 메시지 체인을 사용하는 경우가 좋다고 생각한다.

## 6. ‘가변 데이터’ 와 ‘전역 데이터’ 악취 각각에 대해, 그리고 가변 데이터가 동시에 전역 데이터인 악취에 대해 설명

**[전역데이터]**  
전역데이터를 주의해야한다는 말은 개발을 시작한 초창기부터 꾸준히 듣는 말이다. 전역데이터는 코드베이스 어디에서든 건드릴 수있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제이다. 버그는 끊임없이 발생하는데 , 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 변수 캡슐화하기 이다. 다른 코드에서 오염시킬 가능성이 있든 데이터를 발견할때마다 아 기법을 가장 먼저 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 방법을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도좋다.

**[가변 데이터]**  
데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종있다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한채 수정해버리면 프로그램이 오작동한다. 특히 이 문제가 아주 드문 조건에서만 발생한다면 원인을 파악하기 매우 어렵다.

가변 데이터와 전역 데이터 모두 값을 어느 위치에서나 변경하는데 불안정하다고 말 할 수있다. 변수의 유효범위가 단 몇줄이라면 크게 문제가 없을 수 있지만 코드베이스 전체에서 문제를 일으킬 수 있는 여지가 있다면 리팩터링의 대상이 될 수 있다.
